<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>schwartz.world blog</title>
    <link>https://schwartz.world/blog/</link>
    <description>JS Developer, Dad, Slacker</description>
    
    <item>
        <title>On Typescript</title>
        <pubDate>Sun Sep 27 2020 22:04:31 GMT-0400 (Eastern Daylight Time)</pubDate>
        <link>https://schwartz.world/blog/on_typescript/index.html</link>
        <description><p>I don't like it.</p>
<h3 id="myexperience">My experience</h3>
<p>I work on a large and tangled React codebase. We have two linter rules related to <code>any</code> types:</p>
<ul>
<li>no implicit any</li>
<li>no explicit any</li>
</ul>
<p>The end result is that every function, component has to have a type declaration.</p>
<h3 id="idontlikewritingcodejusttosuitthecompiler">I don't like writing code just to suit the compiler</h3>
<div id="description">
There are two types of people who write TypeScript. For those who come from statically typed languages, Typescript is a way of writing JavaScript without some of the pains of JavaScript. These reluctant JS devs are forced into it because browsers don't speak Java anymore. You can't build a front end in C#.

Then there is me. I started as a JS dev. It's my *lingua materna*. I learned in a web browser console and built websites the old fashioned way without compilers or tooling or anything like that. Just Sublime Text, `python -m SimpleHTTPServer` and a browser window. Later I moved on to React and through my exposure to React I got comfortable in NodeJS.
</div>
<p>For me and, I assume, others like me, there is a particular frustration wherein I write perfectly usable code that will work fine in the environment it is destined for, but the compiler won't accept it. Alternatively, I struggle to come up with flexible typing when needed. The only way to make this stuff work is to write pointless code to appease the tyrannical robot <del>overlord</del><ins>I mean protector</ins> that is the typescript compiler.</p>
<h3 id="largecodebasesmayhavetoomanysimilartypes">Large codebases may have too many similar types</h3>
<p>This is self explanatory, but similar types leave you with three options: write glue code to toggle the types back and forth (bad), add more similar types / duplicated code to avoid the similar types or refactor which could be easier said than done in a large codebase.</p>
<h3 id="typescriptisbestusedwithoop">Typescript is best used with OOP</h3>
<p>Typescript seems to work best when you type your data, not your functions. The language has a lot of little things that work really well with classes. For example, if you are trying to manually check a type, you can use <code>instanceof</code>if the type is an instance of a class. If it's just an object with an interface though, you lose that capability.</p>
<p>Unfortunately, classes are not en vogue in the React community. React pushes a functional model which is great, but the result is that everybody I work with things of typing in terms of input but not output.</p>
<p>React developers often delegate too much responsibility to React. All of their code lives in the body of components, maybe with some hooks and helper functions scattered around. React works best, in my opinion, when most of the work lives outside of React. Instead of continually adding props to components, I want to build a thing and send it tumbling down the React tree with all the information needed to work on it included. Classes are a solid abstraction in JS, and you can make them pure functions just fine.</p>
<p>So the point of this is, the React community largely follows a paradigm that doesn't really work well with TypeScript. It could, but it doesn't. Admittedly I can write the code the way I want, but the whole reason for a language like TS is to make it easier to work with other people's code.</p>
<h3 id="typingfeelslikeanafterthought">Typing feels like an afterthought</h3>
<p>Unlike Elm, where the types are really a first class feature of the language, types in TypeScript feel like they are stapled on, and for me that translates into the code I write. The simplest route to productivity seems to be writing the code first, then fighting with the type system for half a day to appease it. Is there a better way?</p>
<h3 id="insummation">In Summation</h3>
<p>Someday I'd like to try a project with TypeScript my way, and I think I might like that. I'd prefer to use the types conservatively, leaving most code <em>un</em>typed except the most important bits. I probably won't do that unless Deno becomes mainstream enough to seriously contend with Node.</p></description>
    </item>
    
    <item>
        <title>The Hardest And Easiest Part Of React</title>
        <pubDate>Wed Oct 21 2020 14:50:16 GMT-0400 (Eastern Daylight Time)</pubDate>
        <link>https://schwartz.world/blog/the_hardest_and_easiest_part_of_react/index.html</link>
        <description><style>
    body {
        background: #102118;
        color: #82c58b;
    }
    a {
        color: #00db31;
    }
</style>
<h2 id="thehardestandeasiestpartofreactjs">The Hardest and Easiest Part of ReactJS</h2>
<p>In the last year, I switched from a small shop where I was <em>the</em> front-end guy to a bigger one where there are dozens of us. Dozens of us! I've gotten a lot better at reading other people's code as a result, especially React code. React is great in that it has a small, unopinionated API, but that same freedom is also its biggest weakness.</p>
<p>Think about all the varying opinions on React. I'm here to tell you that they are all absolutely right. React is great and React is garbage and it all depends on this one factor, this problem that I keep seeing solved in various wrong ways.</p>
<p>See, there's one rule when it comes to React. Only one. Data flows from the top of the app downward. Pour the champagne into the glass at the top of the pyramid and watch it trickle down. That's your data. The champagne. A lot of the code I see answers this question:</p>
<p><em>"How do I propogate state changes from lower in the tree back up to the top?"</em></p>
<p>You don't. Don't do it. Data from state goes down, not up.</p>
<p><em>"Ok, sure, but I have this state down here and when it changes, I need this other thing higher in the tree to change in response"</em></p>
<p>Your state is in the wrong place.</p>
<p><em>"OK, but this component is fetching user data, which is used all over the app so I'll--"</em></p>
<p>No.</p>
<p><em>"So how do I do it then?"</em></p>
<p>Writing really good React is easy if you understand two core concepts:</p>
<ul>
<li>closures</li>
<li>async programming</li>
</ul>
<p>See, it's not that you can't send data back up the tree, but that it has to be in response to something explicitly happening. The idiomatic way to do it is to pass down a closure which is then called in response to a user action, or as a callback to some asyncronous event.</p>

<h4 id="abadexampleifabitcontrived">A bad example (if a bit contrived):</h4>
<pre><code>const Parent = () => {
    const [id, setId] = useState();
    return &lt;Child id={id} setId={setData} />
}

const Child = ({ id, setId }) => {
    const [fetchedId, setFetchedId] = useState();

    if (!id) {
        someAPIFunction().then((user) => setFetchedData(user.id));
    }

    if (id !== fetchedId) setId(fetchedId);

    return .......
}</code></pre>
<p><em>"Why is this bad?"</em></p>
<p>First of all, the two pieces of state are redundant. They can never not equal the same thing so why have it twice?</p>
<p><em>"Dude, you wrote this strawman code."</em></p>
<p>This time, sure, but I've code reviewed it plenty of times.</p>
<p><em>"Sigh. Fine, continue "</em></p>
<p>Here's an even worse implementation using <code>React.useEffect</code>.</p>
<pre><code>const Child = ({ id, setId }) => {
    const [fetchedId, setFetchedId] = useState();

    if (!id) {
        someAPIFunction().then((user) => setFetchedData(user.id));
    }

    useEffect(() => setId(fetchedId), [setId, fetchedId]);

    return .......
}</code></pre>
<p><em>"Aw, jeez, Schwartz. Nobody would write that"</em>.</p>
<p>It's done all the time, <a href="https://formik.org/docs/examples/dependent-fields">including in documentation for popular libraries</a>. And the point is that, yes it works, but no, that way madness lies. In a large React app, this kind of behavior will shoot you in the foot so flipping fast, because you won't know where changes are coming from.</p>
<p>In my <del>expert</del> <ins>humble</ins> opinion, the right way is to have all your data fetching at the top of the app, so you never have to send data back up the tree.</p>
<p><em>"But I want the query to happen when <code>Child</code> renders, not before."</em></p>
<p>Fair, but I would still setup the query high in the tree, and pass the closure down to get called when <code>Child</code> renders.</p>
<pre><code>const Parent = () => {
    const [id, setId] = useState();
    if (!id) {
        someAPIFunction().then((user) => setFetchedData(user.id));
    }
    return &lt;Child id={id} />
}

const Child = ({ id, setId }) => {
    return .......
}</code></pre>
<p><em>"Seems so easy, but this example is so simple and contrived"</em></p>
<p>It's supposed to be simple. It only gets hard if you forget to refactor as you go. Where to put your state and effects is the fundamental question of React programming. Building out a React app will require you to make assumptions about where state belongs and then <a href="https://reactjs.org/docs/lifting-state-up.html">revisit those assumptions constantly</a>. The first time you ask yourself, how do I propogate this change back up the tree reactively, that's the exact moment you should be questioning where things are located in your app, because data shouldn't move up, but down. Go with the flow.</p></description>
    </item>
    
    <item>
        <title>Archive Bookmarklet</title>
        <pubDate>Fri Sep 25 2020 22:45:49 GMT-0400 (Eastern Daylight Time)</pubDate>
        <link>https://schwartz.world/blog/archive_bookmarklet/index.html</link>
        <description><h2 id="ausefulbookmarkletistumbledacross">A useful Bookmarklet I stumbled across</h2>
<p><a href="https://news.ycombinator.com/item?id=24809650">Shamelessly lifted from the Hacker News Comment</a></p>
<p>Takes you to archive.org's historical record of your site.</p>
<p><code>javascript:void(open('http://archive.today/?run=1&amp;url='+encodeURIComponent(document.location)))
</code></p></description>
    </item>
    
    <item>
        <title>Adding Comments To The Blog</title>
        <pubDate>Tue Sep 29 2020 22:13:32 GMT-0400 (Eastern Daylight Time)</pubDate>
        <link>https://schwartz.world/blog/adding_comments_to_the_blog/index.html</link>
        <description><style>
    body {
        background: pink;
        color: black;
    }
</style>
<p>I've been thinking about comments a lot. This blog is built with my own static site generator, and adding live comments to a site with no backend is no easy task.</p>
<p>I narrowed my options down to these options:</p>
<ul>
<li>Users email their comments. A Node script checks the email once per day and adds the comments to a DB. I generate the HTML at build time.</li>
<li>Build a separate app that sits in <code>the cloud</code> and receives comments posted from the browser. At build time, the static site generator pulls down any new comments and generates the HTML.</li>
<li>Host comments on a third party service not necessarily meant for this purpose (Reddit, Lemmy, <del>Hacker News</del> <ins>The Orange Site</ins>).</li>
</ul>
<p>I did a little searching and found a blog post on using GitHub issues as a backend for a comments system. The GitHub API allows you to request issue comments in JSON format, which makes them very easy to display.</p>
<p>It's all very crude at the moment, but it works. The markdown parsing is the weakest point right now. I figured half-baked comments are better than no comments. But I really need the markdown to be parsed identically to GitHub's.</p></description>
    </item>
    
    <item>
        <title>Static Site Generators</title>
        <pubDate>Fri Sep 25 2020 22:17:28 GMT-0400 (Eastern Daylight Time)</pubDate>
        <link>https://schwartz.world/blog/static_site_generators/index.html</link>
        <description><style>
    body {
      background: indigo;
      color: lightseagreen;
    }
    a {
      color: lightyellow;
    }
</style>
<h2 id="staticsitegenerators">Static Site Generators</h2>
<p>Some people knit. Some bake. Me? I build static site generators. This site is one of them.</p>
<p>My introduction to static site generators was the incredible [Gatsby JS](
www.gatsbyjs.com), and this site was built with Gatsby originally. Gatsby is an amazing product, but I don't want to write React in my off-time.</p>
<p>Even worse, I couldn't make Gatsby work with Leaflet. At the time, I was very interested in JavaScript maps, and there was a quirk where Leaflet would bind itself to the <code>window</code> object before it was instatiated. This may have been fixed since then.</p>
<h3 id="diyisbetter">DIY is Better</h3>
<p>At the end of the day, a static site generator doesn't need much. You need a way to load and parse some files and then pass that content to an HTML template. It doesn't need to be particularly performant or secure since it only ever runs on my machine at home. Static files get generated and then pushed up to Netlify.</p>
<h3 id="plannedfeatures">Planned Features</h3>
<h4 id="comments">Comments</h4>
<p>I really want to figure out a way to have comments, which seems difficult on a static html site. Possibilities (in reverse order of preference):</p>
<ul>
<li>Comments post to node server and are fetched regularly and built into the static blog</li>
<li>Comments post to AWS Lambda and ???</li>
<li><a href="https://formspree.io/">FormSpree</a> form to comment</li>
<li>Email to comment</li>
</ul>
<h4 id="tags">Tags</h4>
<p>I really like the idea of a dynamic tagging system. At build time, I'd like to link the tags to allow links to relevant posts. Tags are better than categories as they allow for discoverability and browsing. I can't say there will ever be enough posts here to justify a system like this, but that's not why I'm doing this. I like building the blog more than I like posting to it. Deeply ironic.</p>
<p><a href="https://www.jwz.org/blog/">This blog</a> has a fantastic system whereby every post has a list of <code>previously</code> links at the bottom. I'd like my tags to function similarly, allowing an organic link from page to page. Damned if I know how I'm going to implement it, but I have ideas.</p>
<h4 id="maps">Maps</h4>
<p>There will be maps. Oh yes. There will be maps.</p>
<h4 id="rss">RSS</h4>
<p>I'd like to generate an RSS feed as well. It's only considerate.</p>
<h3 id="whatwillyouwriteabout">What will you write about?</h3>
<p>Maybe lots of things. Maybe nothing. Maybe I'll tear the whole thing down next month and try again.</p></description>
    </item>
    
    <item>
        <title>Dongles</title>
        <pubDate>Fri Sep 25 2020 13:35:53 GMT-0400 (Eastern Daylight Time)</pubDate>
        <link>https://schwartz.world/blog/dongles/index.html</link>
        <description><style>
    body {
      background: steelblue;
      color: lightgoldenrodyellow;
    }
    a {
      color: firebrick;
      font-weight: bolder;
    }
    h1, h2, h3, h4, h5 {
        color: darkgreen;
    }
</style>
<h2 id="allthedevicesihavethatrequiredongles">All the devices I have that require dongles</h2>
<p>I am on the record as being anti-dongle. It's a battle, and I'm losing it.</p>
<p>Work has provided me with a shiny MacBook pro, which has 4 USB-c ports that have to work for everything.</p>
<p>1) One port is taken up by the power cable. This is a ridiculous design choice, and I believe many of the flaws with new MacBooks are because of it. Sure, it's great to plug your laptop in on either side, I guess. Was that ever a problem for anybody?
<br />
<b>You know what was a problem for me?</b><br/>
Kicking cables by accident. I broke a laptop screen in like 2005.<br/>
<b>You know what fixed it?</b><br/>
MagSafe connectors. RIP.</p>
<p>2) Audio interface</p>
<p>3) Shared between a monitor cable and my keyboard cable</p>
<p>4) Shared between a monitor cable and my trackball mouse</p>
<h2 id="faq">FAQ</h2>
<blockquote>
  <p>Why don't you just get wireless tech to replace your wired tech?</p>
</blockquote>
<p>Besides the fact that I don't want to replace perfectly good peripherals, batteries are a poor design choice. They have an expiration date, another form of planned obsolescence. I'd never pay a penny for AirBuds or whatever they're called without a replaceable battery. My peripherals will work as long as USB is still a standard. Just with dongles…</p>
<p>I refuse to charge my headphones or mouse. That's ridiculous.</p>
<p>Wireless tech is a lot more money too. You can get a mediocre pair of bluetooth headphones for $100 or a really great pair of wired headphones for &lt;$40.</p>
<blockquote>
  <p>Why do you use an audio interface?</p>
</blockquote>
<p>Convenience mostly. Except that I bought mine before USB-C was a thing, so now I need a dongle. Worth mentioning, my computer does have a headphone jack, but my phone doesn't. You need a dongle for that.</p>
<blockquote>
  <p>Why not use a USB hub?</p>
</blockquote>
<p>I guess I could. But I have dongles, so I use them. It's the same difference.</p></description>
    </item>
    
  </channel>
</rss>