<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>schwartz.world blog</title>
    <link>https://schwartz.world/blog/</link>
    <description>JS Developer, Dad, Slacker</description>
    
    <item>
        <title>Adding comments to the blog</title>
        <pubDate>Sat Oct 03 2020</pubDate>
        <link>https://schwartz.world/blog/adding_comments_to_the_blog/index.html</link>
        <description><p>I’ve been thinking about comments a lot. This blog is built with my own static site generator, and adding live comments to a site with no backend is no easy task.</p>
<p>I narrowed my options down to these options:</p>
<ul>
<li>Users email their comments. A Node script checks the email once per day and adds the comments to a DB. I generate the HTML at build time.</li>
<li>Build a separate app that sits in <code>the cloud</code> and receives comments posted from the browser. At build time, the static site generator pulls down any new comments and generates the HTML.</li>
<li>Host comments on a third party service not necessarily meant for this purpose (Reddit, Lemmy, <del>Hacker News</del> <ins>The Orange Site</ins>).</li>
</ul>
<p>I did a little searching and found a blog post on using GitHub issues as a backend for a comments system. The GitHub API allows you to request issue comments in JSON format, which makes them very easy to display.</p>
<p>It’s all very crude at the moment, but it works. The markdown parsing is the weakest point right now. I figured half-baked comments are better than no comments. But I really need the markdown to be parsed identically to GitHub’s.</p>
<h3 id="update-2020-26-10">Update: 2020-26-10</h3>
<p>I’ve updated the build tools for the blog to inlcude Pandoc and JSDom, which gives me the ability to manipulate the generated HTML. Previously, I was parsing the MD with JavaScript and having a heck of a time of it. That means that our links to <code>meta</code> data (like where comments are located), can be left in the HTML with <code>display: none;</code>. If you view the source of this page, you’ll see it right there.</p>

</description>
    </item>
    
    <item>
        <title>Archive bookmarklet</title>
        <pubDate>Wed Sep 23 2020</pubDate>
        <link>https://schwartz.world/blog/archive_bookmarklet/index.html</link>
        <description><h2 id="a-useful-bookmarklet-i-stumbled-across">A useful Bookmarklet I stumbled across</h2>
<p><a href="https://news.ycombinator.com/item?id=24809650">Shamelessly lifted from the Hacker News Comment</a></p>
<p>Takes you to archive.org’s historical record of your site.</p>
<p><code>javascript:void(open('http://archive.today/?run=1&amp;url='+encodeURIComponent(document.location)))</code></p>

</description>
    </item>
    
    <item>
        <title>Converting large movies to smallish mp4s</title>
        <pubDate>Tue Oct 27 2020</pubDate>
        <link>https://schwartz.world/blog/converting_large_movies_to_smallish_mp4s/index.html</link>
        <description><h2 id="converting-large-movies-to-smallish-mp4s-using-ffmpeg">Converting Large Movies to Smallish MP4s using FFMPEG</h2>
<p>Not much to this. I’ve set up a Plex server on a 2011ish MacBook air. This server is also responsible for hosting some homemade services on my local network.</p>
<p>Eventually I’d like to get it working with some sort of attached storage, but at the moment I’m using the MacBook’s HD which is relatively meager once you start filling up the HD with movies. I don’t need much though, since the main purpose is providing my kids with better educational content than is offered on Netlix / Prime / Hulu, as well as allowing us to eliminate our Disney+ subscription. The kids watch the same movies over and over again (he said as he cued up Olaf’s Frozen Adventure for the 10,000th time).</p>
<p>Warning: It isn’t a fast process, at least not on an old-ass MacBook. Doing a full season of a TV show takes forever since FFMPEG goes through line by line.</p>
<p>Warning: This appends <code>.mp4</code> to the filename, meaning <code>some-movie.mkv</code> becomes <code>some-movie.mkv.mp4</code>. I’m working on a bulk file renaming tool to run afterward to format the titles into the Plex naming scheme (<code>"MASH s01e09"</code>).</p>
<p>#feet</p>
<h4 id="bash">BASH</h4>
<pre><code>shrinkmov() {
    for movie in *;
    do;
        ffmpeg -i $movie -c:v libx264 -crf 18 "$movie.mp4" &amp;&amp; rm $movie;
    done;
}</code></pre>
<h4 id="zsh">ZSH</h4>
<pre><code>shrinkmov() {
    for movie in $(ls);
    do;
        ffmpeg -i $movie -c:v libx264 -crf 18 "$movie.mp4" &amp;&amp; rm $movie;
    done;
}</code></pre>

</description>
    </item>
    
    <item>
        <title>Dongles</title>
        <pubDate>Fri Sep 25 2020</pubDate>
        <link>https://schwartz.world/blog/dongles/index.html</link>
        <description><h2 id="all-the-devices-i-have-that-require-dongles">All the devices I have that require dongles</h2>
<p>I am on the record as being anti-dongle. It’s a battle, and I’m losing it.</p>
<p>Work has provided me with a shiny MacBook pro, which has 4 USB-c ports that have to work for everything.</p>
<ol type="1">
<li><p>One port is taken up by the power cable. This is a ridiculous design choice, and I believe many of the flaws with new MacBooks are because of it. Sure, it’s great to plug your laptop in on either side, I guess. Was that ever a problem for anybody?  <b>You know what was a problem for me?</b> Kicking cables by accident. I broke a laptop screen in like 2005. <b>You know what fixed it?</b> MagSafe connectors. RIP.</p></li>
<li><p>Audio interface</p></li>
<li><p>Shared between a monitor cable and my keyboard cable</p></li>
<li><p>Shared between a monitor cable and my trackball mouse</p></li>
</ol>
<h2 id="faq">FAQ</h2>
<blockquote>
<p>Why don’t you just get wireless tech to replace your wired tech?</p>
</blockquote>
<p>Besides the fact that I don’t want to replace perfectly good peripherals, batteries are a poor design choice. They have an expiration date, another form of planned obsolescence. I’d never pay a penny for AirBuds or whatever they’re called without a replaceable battery. My peripherals will work as long as USB is still a standard. Just with dongles…</p>
<p>I refuse to charge my headphones or mouse. That’s ridiculous.</p>
<p>Wireless tech is a lot more money too. You can get a mediocre pair of bluetooth headphones for $100 or a really great pair of wired headphones for &lt;$40.</p>
<blockquote>
<p>Why do you use an audio interface?</p>
</blockquote>
<p>Convenience mostly. Except that I bought mine before USB-C was a thing, so now I need a dongle. Worth mentioning, my computer does have a headphone jack, but my phone doesn’t. You need a dongle for that.</p>
<blockquote>
<p>Why not use a USB hub?</p>
</blockquote>
<p>I guess I could. But I have dongles, so I use them. It’s the same difference.</p>
</description>
    </item>
    
    <item>
        <title>Educational tv</title>
        <pubDate>Tue Oct 27 2020</pubDate>
        <link>https://schwartz.world/blog/educational_tv/index.html</link>
        <description>
<p>I don’t want to be one of those complaining old men, constantly bemoaning every difference that I see between the world of my youth and that of today.I’m not that old anyway; at 38 I consider myself to be just barely reaching adulthood.</p>
<p>I have two small children of the girl persuasion, ages 2 and 4. The pandemic has changed so much about their lives, but one change is that we all have a lot more screen time than before.</p>
<p>Children’s programming is shit today. Boring computer-generated animation, interchangeable characters with impossibly cheerful voices. Most of it seems lazy and half-baked. You could take the plots and characters from any number of shows and switch them around and it would all fit fine. I’m talking about shows like <em>PJ Masks</em>, <em>Paw Patrol</em>, and <em>Mickey Mouse Clubhouse</em>.</p>
<p><em>Mickey Mouse Clubhouse</em> is a particularly bad offender, because I have such strong childhood attachments to the source material. It might be the worst show ever made. It’s weird, but not in a fun way like <em>Yo Gabba Gabba</em>. Completely humorless.</p>
<p>Even <em>Sesame Street</em>, of which I am a staunch advocate, uses obvious filler sketches like <a href="https://www.youtube.com/watch?v=M6TkpZx1dzQ"><em>Journey to Ernie</em></a>, which is absolute garbage.</p>
<p>Contrast that to the shows I watched as a kid. We’ve been playing <em>Fraggle Rock</em>, <em>The Elephant Show</em>, <em>Magic Schoolbus</em>, <em>Beakman’s World</em>, <em>Bill Nye the Science Guy</em>. They’re just better.</p>
<p>The Fraggles are such well-developed characters, and the show does such a good job of showing the fragile beauty of their ecosystem. There are layers of information that can be gleaned on subsequent rewatches. As children mature, there are jokes and nuances they start to grasp. The show is actually entertaining for adults.</p>
<p>Contrast that to <em>The PJ Masks</em>, a show that makes me want to actually put my head through the TV.</p>
</description>
    </item>
    
    <item>
        <title>Fudgy brownie cupcakes</title>
        <pubDate>Mon Oct 26 2020</pubDate>
        <link>https://schwartz.world/blog/fudgy_brownie_cupcakes/index.html</link>
        <description><h2 id="brownie-cupcakes-recipe"><a href="https://www.alsothecrumbsplease.com/brownie-cupcakes-recipe/">Brownie Cupcakes Recipe</a></h2>
<h3 id="ingredients">Ingredients</h3>
<ul>
<li>1 cup butter, melted and cooled (226g)</li>
<li>2 cups granulated white sugar (400g)</li>
<li>4 large eggs</li>
<li>2 vanilla beans* (or 2 tsp pure vanilla extract)</li>
<li>1 cup dutch-processed cocoa powder (84g)</li>
<li>1 cup all-purpose flour (120g)</li>
<li>1 tsp salt</li>
</ul>
<h3 id="instructions">Instructions</h3>
<p>Preheat oven to 350°F / 175°C. Line two 12 cup muffin pans with 13-14 cupcake liners. Set aside.</p>
<p>Stir together butter, sugar, eggs, and vanilla just until combined. Don’t use a hand or stand mixer otherwise you have too much air pockets in the batter, and this makes them cakey instead of fudgy. Stir by hand with a whisk. Sift in flour, cocoa, and salt and stir just until combined.</p>
<p>Spoon batter with an ice cream scoop into the liners and fill almost full.</p>
<p>Bake for 22-26 minutes until the tops look crinkled and a toothpick centered in the middle comes out slightly dirty. Don’t overbake them or they are getting cakey. I baked mine for exactly 25 minutes. Remove from the oven and let cool for 10 minutes. Then carefully remove from pan and transfer to a wire rack and let cool completely before frosting.</p>

</description>
    </item>
    
    <item>
        <title>On dongles</title>
        <pubDate>Tue Oct 27 2020</pubDate>
        <link>https://schwartz.world/blog/on_dongles/index.html</link>
        <description></description>
    </item>
    
    <item>
        <title>On typescript</title>
        <pubDate>Tue Sep 15 2020</pubDate>
        <link>https://schwartz.world/blog/on_typescript/index.html</link>
        <description><p>I don’t like it.</p>
<h3 id="my-experience">My experience</h3>
<p>I work on a large and tangled React codebase. We have two linter rules related to <code>any</code> types:</p>
<ul>
<li>no implicit any</li>
<li>no explicit any</li>
</ul>
<p>The end result is that every function, component has to have a type declaration.</p>
<h3 id="i-dont-like-writing-code-just-to-suit-the-compiler">I don’t like writing code just to suit the compiler</h3>
<div id="description">
<p>There are two types of people who write TypeScript. For those who come from statically typed languages, Typescript is a way of writing JavaScript without some of the pains of JavaScript. These reluctant JS devs are forced into it because browsers don’t speak Java anymore. You can’t build a front end in C#.</p>
<p>Then there is me. I started as a JS dev. It’s my <em>lingua materna</em>. I learned in a web browser console and built websites the old fashioned way without compilers or tooling or anything like that. Just Sublime Text, <code>python -m SimpleHTTPServer</code> and a browser window. Later I moved on to React and through my exposure to React I got comfortable in NodeJS.</p>
</div>
<p>For me and, I assume, others like me, there is a particular frustration wherein I write perfectly usable code that will work fine in the environment it is destined for, but the compiler won’t accept it. Alternatively, I struggle to come up with flexible typing when needed. The only way to make this stuff work is to write pointless code to appease the tyrannical robot <del>overlord</del><ins>I mean protector</ins> that is the typescript compiler.</p>
<h3 id="large-codebases-may-have-too-many-similar-types">Large codebases may have too many similar types</h3>
<p>This is self explanatory, but similar types leave you with three options: write glue code to toggle the types back and forth (bad), add more similar types / duplicated code to avoid the similar types or refactor which could be easier said than done in a large codebase.</p>
<h3 id="typescript-is-best-used-with-oop">Typescript is best used with OOP</h3>
<p>Typescript seems to work best when you type your data, not your functions. The language has a lot of little things that work really well with classes. For example, if you are trying to manually check a type, you can use <code>instanceof</code>if the type is an instance of a class. If it’s just an object with an interface though, you lose that capability.</p>
<p>Unfortunately, classes are not en vogue in the React community. React pushes a functional model which is great, but the result is that everybody I work with things of typing in terms of input but not output.</p>
<p>React developers often delegate too much responsibility to React. All of their code lives in the body of components, maybe with some hooks and helper functions scattered around. React works best, in my opinion, when most of the work lives outside of React. Instead of continually adding props to components, I want to build a thing and send it tumbling down the React tree with all the information needed to work on it included. Classes are a solid abstraction in JS, and you can make them pure functions just fine.</p>
<p>So the point of this is, the React community largely follows a paradigm that doesn’t really work well with TypeScript. It could, but it doesn’t. Admittedly I can write the code the way I want, but the whole reason for a language like TS is to make it easier to work with other people’s code.</p>
<h3 id="typing-feels-like-an-afterthought">Typing feels like an afterthought</h3>
<p>Unlike Elm, where the types are really a first class feature of the language, types in TypeScript feel like they are stapled on, and for me that translates into the code I write. The simplest route to productivity seems to be writing the code first, then fighting with the type system for half a day to appease it. Is there a better way?</p>
<h3 id="in-summation">In Summation</h3>
<p>Someday I’d like to try a project with TypeScript my way, and I think I might like that. I’d prefer to use the types conservatively, leaving most code <em>un</em>typed except the most important bits. I probably won’t do that unless Deno becomes mainstream enough to seriously contend with Node.</p>

</description>
    </item>
    
    <item>
        <title>Static site generators</title>
        <pubDate>Thu Sep 10 2020</pubDate>
        <link>https://schwartz.world/blog/static_site_generators/index.html</link>
        <description><h2 id="static-site-generators">Static Site Generators</h2>
<p>Some people knit. Some bake. Me? I build static site generators. This site is one of them.</p>
<p>My introduction to static site generators was the incredible <a href="www.gatsbyjs.com">Gatsby JS</a>, and this site was built with Gatsby originally. Gatsby is an amazing product, but I don’t want to write React in my off-time.</p>
<p>Even worse, I couldn’t make Gatsby work with Leaflet. At the time, I was very interested in JavaScript maps, and there was a quirk where Leaflet would bind itself to the <code>window</code> object before it was instatiated. This may have been fixed since then.</p>
<h3 id="diy-is-better">DIY is Better</h3>
<p>At the end of the day, a static site generator doesn’t need much. You need a way to load and parse some files and then pass that content to an HTML template. It doesn’t need to be particularly performant or secure since it only ever runs on my machine at home. Static files get generated and then pushed up to Netlify.</p>
<h3 id="planned-features">Planned Features</h3>
<h4 id="comments-done"><del>Comments</del> <ins>DONE!</ins></h4>
<p>I really want to figure out a way to have comments, which seems difficult on a static html site. Possibilities (in reverse order of preference):</p>
<ul>
<li>Comments post to node server and are fetched regularly and built into the static blog</li>
<li>Comments post to AWS Lambda and ???</li>
<li><a href="https://formspree.io/">FormSpree</a> form to comment</li>
<li>Email to comment</li>
</ul>
<h4 id="tags---in-progress">Tags - In Progress</h4>
<p>I really like the idea of a dynamic tagging system. At build time, I’d like to link the tags to allow links to relevant posts. Tags are better than categories as they allow for discoverability and browsing. I can’t say there will ever be enough posts here to justify a system like this, but that’s not why I’m doing this. I like building the blog more than I like posting to it. Deeply ironic.</p>
<p><a href="https://www.jwz.org/blog/">This blog</a> has a fantastic system whereby every post has a list of <code>previously</code> links at the bottom. I’d like my tags to function similarly, allowing an organic link from page to page. Damned if I know how I’m going to implement it, but I have ideas.</p>
<h4 id="maps">Maps</h4>
<p>There will be maps. Oh yes. There will be maps.</p>
<h4 id="rss">RSS</h4>
<p>I’d like to generate an RSS feed as well. It’s only considerate.</p>
<h3 id="what-will-you-write-about">What will you write about?</h3>
<p>Maybe lots of things. Maybe nothing. Maybe I’ll tear the whole thing down next month and try again.</p>

</description>
    </item>
    
    <item>
        <title>The hardest and easiest part of react</title>
        <pubDate>Wed Sep 23 2020</pubDate>
        <link>https://schwartz.world/blog/the_hardest_and_easiest_part_of_react/index.html</link>
        <description>

<h2 id="the-hardest-and-easiest-part-of-reactjs">The Hardest and Easiest Part of ReactJS</h2>
<p>In the last year, I switched from a small shop where I was <em>the</em> front-end guy to a bigger one where there are dozens of us. Dozens of us! I’ve gotten a lot better at reading other people’s code as a result, especially React code. React is great in that it has a small, unopinionated API, but that same freedom is also its biggest weakness.</p>
<p>Think about all the varying opinions on React. I’m here to tell you that they are all absolutely right. React is great and React is garbage and it all depends on this one factor, this problem that I keep seeing solved in various wrong ways.</p>
<p>See, there’s one rule when it comes to React. Only one. Data flows from the top of the app downward. Pour the champagne into the glass at the top of the pyramid and watch it trickle down. That’s your data. The champagne. A lot of the code I see answers this question:</p>
<p><em>“How do I propogate state changes from lower in the tree back up to the top?”</em></p>
<p>You don’t. Don’t do it. Data from state goes down, not up.</p>
<p><em>“Ok, sure, but I have this state down here and when it changes, I need this other thing higher in the tree to change in response”</em></p>
<p>Your state is in the wrong place.</p>
<p><em>“OK, but this component is fetching user data, which is used all over the app so I’ll–”</em></p>
<p>No.</p>
<p><em>“So how do I do it then?”</em></p>
<p>Writing really good React is easy if you understand two core concepts:</p>
<ul>
<li>closures</li>
<li>async programming</li>
</ul>
<p>See, it’s not that you can’t send data back up the tree, but that it has to be in response to something explicitly happening. The idiomatic way to do it is to pass down a closure which is then called in response to a user action, or as a callback to some asyncronous event.</p>

<h4 id="a-bad-example-if-a-bit-contrived">A bad example (if a bit contrived):</h4>
<pre><code>const Parent = () =&gt; {
    const [id, setId] = useState();
    return &lt;Child id={id} setId={setData} /&gt;
}

const Child = ({ id, setId }) =&gt; {
    const [fetchedId, setFetchedId] = useState();

    if (!id) {
        someAPIFunction().then((user) =&gt; setFetchedData(user.id));
    }

    if (id !== fetchedId) setId(fetchedId);

    return .......
}</code></pre>
<p><em>“Why is this bad?”</em></p>
<p>First of all, the two pieces of state are redundant. They can never not equal the same thing so why have it twice?</p>
<p><em>“Dude, you wrote this strawman code.”</em></p>
<p>This time, sure, but I’ve code reviewed it plenty of times.</p>
<p><em>“Sigh. Fine, continue”</em></p>
<p>Here’s an even worse implementation using <code>React.useEffect</code>.</p>
<pre><code>const Child = ({ id, setId }) =&gt; {
    const [fetchedId, setFetchedId] = useState();

    if (!id) {
        someAPIFunction().then((user) =&gt; setFetchedData(user.id));
    }

    useEffect(() =&gt; setId(fetchedId), [setId, fetchedId]);

    return .......
}</code></pre>
<p><em>“Aw, jeez, Schwartz. Nobody would write that”</em>.</p>
<p>It’s done all the time, <a href="https://formik.org/docs/examples/dependent-fields">including in documentation for popular libraries</a>. And the point is that, yes it works, but no, that way madness lies. In a large React app, this kind of behavior will shoot you in the foot so flipping fast, because you won’t know where changes are coming from.</p>
<p>In my <del>expert</del> <ins>humble</ins> opinion, the right way is to have all your data fetching at the top of the app, so you never have to send data back up the tree.</p>
<p><em>“But I want the query to happen when <code>Child</code> renders, not before.”</em></p>
<p>Fair, but I would still setup the query high in the tree, and pass the closure down to get called when <code>Child</code> renders.</p>
<pre><code>const Parent = () =&gt; {
    const [id, setId] = useState();
    const [loading, setLoading] = useState(false);

    const fetchData = () {
        setLoading(true);
        someAPIFunction()
          .then((user) =&gt; setFetchedData(user.id))
          .finally(() =&gt; setLoading(false);
    };

    return &lt;Child id={id} onLoad={fetchData} loading={loading} /&gt;
}

const Child = ({ id, onLoad, loading }) =&gt; {
    if (!id &amp;&amp; !loading) {
      onLoad();
    }
    return .......
}</code></pre>
<p>The difference is that we are executing the query high in the tree and storing the state high in the tree. The child component can still be in charge of calling the function.</p>
<p>This also makes testing much easier, as testing <code>Child</code> doesn’t require mocking the API response at all. You can just check that it calls its <code>onLoad</code> method when it first loads. You could further abstract the loading and data fetching behavior behind a custom hook that can also be tested in isolation.</p>
<p><em>“Seems so easy, but this example is so simple and contrived”</em></p>
<p>It’s supposed to be simple. It only gets hard if you forget to refactor as you go. Where to put your state and effects is the fundamental question of React programming. Building out a React app will require you to make assumptions about where state belongs and then <a href="https://reactjs.org/docs/lifting-state-up.html">revisit those assumptions constantly</a>. The first time you ask yourself, how do I propogate this change back up the tree reactively, that’s the exact moment you should be questioning where things are located in your app, because data shouldn’t move up, but down. Go with the flow.</p>
</description>
    </item>
    
  </channel>
</rss>